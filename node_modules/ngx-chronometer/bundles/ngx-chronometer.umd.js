(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/core'), require('lodash')) :
    typeof define === 'function' && define.amd ? define('ngx-chronometer', ['exports', 'rxjs', '@angular/core', 'lodash'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-chronometer'] = {}, global.rxjs, global.ng.core, global._));
}(this, (function (exports, rxjs, core, _) { 'use strict';

    exports.TimeChonometer = void 0;
    (function (TimeChonometer) {
        TimeChonometer[TimeChonometer["timemedio"] = 0] = "timemedio";
        TimeChonometer[TimeChonometer["timeone"] = 1] = "timeone";
        TimeChonometer[TimeChonometer["timetwo"] = 2] = "timetwo";
    })(exports.TimeChonometer || (exports.TimeChonometer = {}));
    exports.StatusChonometer = void 0;
    (function (StatusChonometer) {
        StatusChonometer[StatusChonometer["desactived"] = 0] = "desactived";
        StatusChonometer[StatusChonometer["pause"] = 1] = "pause";
        StatusChonometer[StatusChonometer["start"] = 2] = "start";
        StatusChonometer[StatusChonometer["finish"] = 3] = "finish";
        StatusChonometer[StatusChonometer["restart"] = 4] = "restart";
        StatusChonometer[StatusChonometer["stop"] = 5] = "stop";
        StatusChonometer[StatusChonometer["refresh"] = 6] = "refresh";
    })(exports.StatusChonometer || (exports.StatusChonometer = {}));
    var Chronometer = /** @class */ (function () {
        /**
         * @description Constructor of class
         * @param o Object default = {}
         */
        function Chronometer(o) {
            if (o === void 0) { o = {}; }
            this.time = new Array(0, 0, 0);
            this.onChronometer = new rxjs.Subject();
            this.id = o.id;
            this.second = o.second || 0;
            this.status = o.status || exports.StatusChonometer.pause;
            this.timeLabel = o.timeLabel;
            this.maxSecond = o.maxSecond || 60;
            this.maxMinute = o.maxMinute || 60;
            this.maxHour = o.maxHour || 60;
            this.limitSecond = o.limitSecond;
        }
        Chronometer.prototype.start = function () {
            this.status = exports.StatusChonometer.start;
            this.onChronometer.next(this);
        };
        Chronometer.prototype.pause = function () {
            this.status = exports.StatusChonometer.pause;
            this.onChronometer.next(this);
        };
        Chronometer.prototype.restart = function () {
            this.status = exports.StatusChonometer.restart;
            this.onChronometer.next(this);
        };
        Chronometer.prototype.stop = function () {
            this.status = exports.StatusChonometer.stop;
            this.onChronometer.next(this);
        };
        Chronometer.prototype.refresh = function () {
            this.onChronometer.next(this);
        };
        return Chronometer;
    }());

    var NgxChronometerDirective = /** @class */ (function () {
        function NgxChronometerDirective() {
            // tslint:disable-next-line:variable-name
            this._chronometer = new Chronometer();
            /** sequence the time default 1000 = 1 second */
            this.interval = 1000;
            /** increment 1 unit */
            this.increment = 1;
            /** format to use default 00:00:00 custom 00/00/00 or other delimiter */
            this.format = '00:00:00';
            /** activated emit event sequence chronometer default false */
            this.chronoEvents = false;
            // tslint:disable-next-line:no-output-on-prefix
            this.onChronoEvent = new core.EventEmitter();
        }
        Object.defineProperty(NgxChronometerDirective.prototype, "chronometer", {
            /** object chronometer */
            set: function (chronometer) {
                chronometer = chronometer || new Chronometer();
                chronometer.maxSecond = this.maxSecond || chronometer.maxSecond || 60;
                chronometer.maxMinute = this.maxMinute || chronometer.maxMinute || 60;
                chronometer.maxHour = this.maxHour || chronometer.maxHour || 60;
                chronometer.time = new Array(0, 0, 0);
                this._chronometer = this.activated(this.currentSecond(chronometer));
            },
            enumerable: false,
            configurable: true
        });
        NgxChronometerDirective.prototype.ngOnInit = function () {
            var _this = this;
            // tslint:disable-next-line:max-line-length
            if (this._chronometer.onChronometer.observers == null) {
                this._chronometer.onChronometer = new rxjs.Subject();
            }
            this.chronoSub = this._chronometer.onChronometer.subscribe(function (chronometer) {
                _this._chronometer = _this.activated(_this.currentSecond(chronometer));
            });
        };
        /**
         * @description current seconds
         * @param chronometer object current chronometer
         * @see {Chronometer}
         */
        NgxChronometerDirective.prototype.currentSecond = function (chronometer) {
            var limitSecond = this.limitSecond || chronometer.limitSecond;
            if (limitSecond && chronometer.second > limitSecond) {
                chronometer.second = limitSecond;
                chronometer.pause();
                this._chronometer = chronometer;
                if (this._chronometer.intervalSub) {
                    this._chronometer.intervalSub.unsubscribe();
                }
                this._chronometer.intervalSub = undefined;
            }
            return chronometer;
        };
        /**
         * @description activated chronometer
         * @param chronometer object current chronometer
         * @see {Chronometer}
         */
        NgxChronometerDirective.prototype.activated = function (chronometer) {
            if (chronometer === void 0) { chronometer = this._chronometer; }
            switch (chronometer.status) {
                case exports.StatusChonometer.pause:
                    this._chronometer = this.pause(chronometer);
                    break;
                case exports.StatusChonometer.start:
                    this._chronometer = this.start(this.pause(chronometer));
                    break;
                case exports.StatusChonometer.restart:
                    chronometer.second = 0;
                    this._chronometer = this.start(chronometer);
                    break;
                case exports.StatusChonometer.stop:
                    chronometer.second = 0;
                    this._chronometer = this.pause(chronometer);
                    break;
                default:
                    break;
            }
            return this.setTime(chronometer, 0);
        };
        /**
         * @description pause seconds
         * @param chronometer object current chronometer
         * @see {Chronometer}
         */
        NgxChronometerDirective.prototype.pause = function (chronometer) {
            return this.stop(chronometer);
        };
        /**
         * @description stop seconds
         * @param chronometer object current chronometer
         * @see {Chronometer}
         */
        NgxChronometerDirective.prototype.stop = function (chronometer) {
            if (chronometer.intervalSub) {
                chronometer.intervalSub.unsubscribe();
                chronometer.intervalSub = undefined;
            }
            return chronometer;
        };
        /**
         * @description start seconds
         * @param chronometer object current chronometer
         * @see {Chronometer}
         */
        NgxChronometerDirective.prototype.start = function (chronometer) {
            var _this = this;
            chronometer.status = 2;
            if (!chronometer.intervalSub) {
                chronometer.intervalSub = rxjs.interval(this.interval).subscribe(function () {
                    chronometer = _this.currentSecond(_this.setTime(chronometer));
                });
            }
            return chronometer;
        };
        Object.defineProperty(NgxChronometerDirective.prototype, "innerText", {
            /**
             * @description inner the text element
             * @see {Chronometer}
             */
            get: function () {
                var sep = (this.format || '').split('00');
                var a = this.isMinutes ? 1 : 0;
                switch (sep.length) {
                    case 1: return "" + sep[0] + this.timeFormat[a] + sep[1];
                    case 2: return "" + sep[0] + this.timeFormat[a] + sep[1];
                    case 3: return "" + sep[0] + this.timeFormat[1] + sep[1] + this.timeFormat[0] + sep[2];
                    case 4: return "" + sep[0] + this.timeFormat[2] + sep[1] + this.timeFormat[1] + sep[2] + this.timeFormat[0] + sep[3];
                    default: return "" + sep[0] + this.timeFormat[2] + sep[1] + this.timeFormat[1] + sep[2] + this.timeFormat[0] + sep[3];
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxChronometerDirective.prototype, "timeFormat", {
            /**
             * @description format array time
             * @see {Chronometer}
             */
            get: function () {
                var time = this._chronometer.time;
                return Array(this.formatNumber(time[2]), this.formatNumber(time[1]), this.formatNumber(time[0]));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @description return string 2 digit
         * @param n number to format
         */
        NgxChronometerDirective.prototype.formatNumber = function (n) {
            return "" + (n > 9 ? n : "0" + n);
        };
        /**
         * @description validator number
         * @param n number to valid
         */
        NgxChronometerDirective.prototype.validNumber = function (n) {
            var enc = !_.isNaN(_.isNumber(n)) && n > 0;
            if (!enc) {
                console.error('Outdid maximo time no valid', n);
                this._chronometer.pause();
            }
            return enc ? n : 60;
        };
        /**
         * @description
         * @param chronometer object current chronometer
         * @see {Chronometer}
         * @param second increment the time
         * @see {increment} default [increment]="1"
         */
        NgxChronometerDirective.prototype.setTime = function (chronometer, second) {
            if (second === void 0) { second = this.increment; }
            if (chronometer.second >= 0) {
                chronometer.second = chronometer.second + second;
                var diffSS = this.validNumber(chronometer.maxSecond);
                var diffMM = this.validNumber(chronometer.maxMinute);
                var hh = Math.trunc((chronometer.second / this.validNumber(chronometer.maxSecond)) / this.validNumber(chronometer.maxMinute));
                var mm = Math.trunc(chronometer.second / this.validNumber(chronometer.maxSecond)) - hh * diffMM;
                var ss = chronometer.second - Math.trunc(chronometer.second / diffSS) * diffSS;
                if (hh === chronometer.maxHour) {
                    chronometer.second = 0;
                    chronometer.time = new Array(0, 0, 0);
                }
                else {
                    chronometer.time = new Array(hh, mm, ss);
                }
            }
            if (this.chronoEvents) {
                this.onChronoEvent.emit(chronometer);
            }
            return chronometer;
        };
        NgxChronometerDirective.prototype.ngOnDestroy = function () {
            if (this.chronoSub) {
                this.chronoSub.unsubscribe();
            }
            if (this._chronometer.intervalSub) {
                this._chronometer.intervalSub.unsubscribe();
            }
            this._chronometer.onChronometer.unsubscribe();
        };
        return NgxChronometerDirective;
    }());
    NgxChronometerDirective.decorators = [
        { type: core.Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: '[chronometer]',
                    // tslint:disable-next-line:no-host-metadata-property
                    host: {
                        '[innerText]': 'innerText'
                    }
                },] }
    ];
    NgxChronometerDirective.ctorParameters = function () { return []; };
    NgxChronometerDirective.propDecorators = {
        interval: [{ type: core.Input }],
        increment: [{ type: core.Input }],
        limitSecond: [{ type: core.Input }],
        maxSecond: [{ type: core.Input }],
        maxMinute: [{ type: core.Input }],
        maxHour: [{ type: core.Input }],
        isMinutes: [{ type: core.Input }],
        chronometer: [{ type: core.Input }],
        format: [{ type: core.Input }],
        chronoEvents: [{ type: core.Input }],
        onChronoEvent: [{ type: core.Output }]
    };

    var NgxChronometerModule = /** @class */ (function () {
        function NgxChronometerModule() {
        }
        return NgxChronometerModule;
    }());
    NgxChronometerModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [NgxChronometerDirective],
                    imports: [],
                    exports: [NgxChronometerDirective],
                    schemas: [core.CUSTOM_ELEMENTS_SCHEMA]
                },] }
    ];

    /*
     * Public API Surface of ngx-chronometer
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.Chronometer = Chronometer;
    exports.NgxChronometerModule = NgxChronometerModule;
    exports.ɵa = NgxChronometerDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-chronometer.umd.js.map
