import { Subject, interval } from 'rxjs';
import { EventEmitter, Directive, Input, Output, NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { isNaN, isNumber } from 'lodash';

var TimeChonometer;
(function (TimeChonometer) {
    TimeChonometer[TimeChonometer["timemedio"] = 0] = "timemedio";
    TimeChonometer[TimeChonometer["timeone"] = 1] = "timeone";
    TimeChonometer[TimeChonometer["timetwo"] = 2] = "timetwo";
})(TimeChonometer || (TimeChonometer = {}));
var StatusChonometer;
(function (StatusChonometer) {
    StatusChonometer[StatusChonometer["desactived"] = 0] = "desactived";
    StatusChonometer[StatusChonometer["pause"] = 1] = "pause";
    StatusChonometer[StatusChonometer["start"] = 2] = "start";
    StatusChonometer[StatusChonometer["finish"] = 3] = "finish";
    StatusChonometer[StatusChonometer["restart"] = 4] = "restart";
    StatusChonometer[StatusChonometer["stop"] = 5] = "stop";
    StatusChonometer[StatusChonometer["refresh"] = 6] = "refresh";
})(StatusChonometer || (StatusChonometer = {}));
class Chronometer {
    /**
     * @description Constructor of class
     * @param o Object default = {}
     */
    constructor(o = {}) {
        this.time = new Array(0, 0, 0);
        this.onChronometer = new Subject();
        this.id = o.id;
        this.second = o.second || 0;
        this.status = o.status || StatusChonometer.pause;
        this.timeLabel = o.timeLabel;
        this.maxSecond = o.maxSecond || 60;
        this.maxMinute = o.maxMinute || 60;
        this.maxHour = o.maxHour || 60;
        this.limitSecond = o.limitSecond;
    }
    start() {
        this.status = StatusChonometer.start;
        this.onChronometer.next(this);
    }
    pause() {
        this.status = StatusChonometer.pause;
        this.onChronometer.next(this);
    }
    restart() {
        this.status = StatusChonometer.restart;
        this.onChronometer.next(this);
    }
    stop() {
        this.status = StatusChonometer.stop;
        this.onChronometer.next(this);
    }
    refresh() {
        this.onChronometer.next(this);
    }
}

class NgxChronometerDirective {
    constructor() {
        // tslint:disable-next-line:variable-name
        this._chronometer = new Chronometer();
        /** sequence the time default 1000 = 1 second */
        this.interval = 1000;
        /** increment 1 unit */
        this.increment = 1;
        /** format to use default 00:00:00 custom 00/00/00 or other delimiter */
        this.format = '00:00:00';
        /** activated emit event sequence chronometer default false */
        this.chronoEvents = false;
        // tslint:disable-next-line:no-output-on-prefix
        this.onChronoEvent = new EventEmitter();
    }
    /** object chronometer */
    set chronometer(chronometer) {
        chronometer = chronometer || new Chronometer();
        chronometer.maxSecond = this.maxSecond || chronometer.maxSecond || 60;
        chronometer.maxMinute = this.maxMinute || chronometer.maxMinute || 60;
        chronometer.maxHour = this.maxHour || chronometer.maxHour || 60;
        chronometer.time = new Array(0, 0, 0);
        this._chronometer = this.activated(this.currentSecond(chronometer));
    }
    ngOnInit() {
        // tslint:disable-next-line:max-line-length
        if (this._chronometer.onChronometer.observers == null) {
            this._chronometer.onChronometer = new Subject();
        }
        this.chronoSub = this._chronometer.onChronometer.subscribe((chronometer) => {
            this._chronometer = this.activated(this.currentSecond(chronometer));
        });
    }
    /**
     * @description current seconds
     * @param chronometer object current chronometer
     * @see {Chronometer}
     */
    currentSecond(chronometer) {
        const limitSecond = this.limitSecond || chronometer.limitSecond;
        if (limitSecond && chronometer.second > limitSecond) {
            chronometer.second = limitSecond;
            chronometer.pause();
            this._chronometer = chronometer;
            if (this._chronometer.intervalSub) {
                this._chronometer.intervalSub.unsubscribe();
            }
            this._chronometer.intervalSub = undefined;
        }
        return chronometer;
    }
    /**
     * @description activated chronometer
     * @param chronometer object current chronometer
     * @see {Chronometer}
     */
    activated(chronometer = this._chronometer) {
        switch (chronometer.status) {
            case StatusChonometer.pause:
                this._chronometer = this.pause(chronometer);
                break;
            case StatusChonometer.start:
                this._chronometer = this.start(this.pause(chronometer));
                break;
            case StatusChonometer.restart:
                chronometer.second = 0;
                this._chronometer = this.start(chronometer);
                break;
            case StatusChonometer.stop:
                chronometer.second = 0;
                this._chronometer = this.pause(chronometer);
                break;
            default:
                break;
        }
        return this.setTime(chronometer, 0);
    }
    /**
     * @description pause seconds
     * @param chronometer object current chronometer
     * @see {Chronometer}
     */
    pause(chronometer) {
        return this.stop(chronometer);
    }
    /**
     * @description stop seconds
     * @param chronometer object current chronometer
     * @see {Chronometer}
     */
    stop(chronometer) {
        if (chronometer.intervalSub) {
            chronometer.intervalSub.unsubscribe();
            chronometer.intervalSub = undefined;
        }
        return chronometer;
    }
    /**
     * @description start seconds
     * @param chronometer object current chronometer
     * @see {Chronometer}
     */
    start(chronometer) {
        chronometer.status = 2;
        if (!chronometer.intervalSub) {
            chronometer.intervalSub = interval(this.interval).subscribe(() => {
                chronometer = this.currentSecond(this.setTime(chronometer));
            });
        }
        return chronometer;
    }
    /**
     * @description inner the text element
     * @see {Chronometer}
     */
    get innerText() {
        const sep = (this.format || '').split('00');
        const a = this.isMinutes ? 1 : 0;
        switch (sep.length) {
            case 1: return `${sep[0]}${this.timeFormat[a]}${sep[1]}`;
            case 2: return `${sep[0]}${this.timeFormat[a]}${sep[1]}`;
            case 3: return `${sep[0]}${this.timeFormat[1]}${sep[1]}${this.timeFormat[0]}${sep[2]}`;
            case 4: return `${sep[0]}${this.timeFormat[2]}${sep[1]}${this.timeFormat[1]}${sep[2]}${this.timeFormat[0]}${sep[3]}`;
            default: return `${sep[0]}${this.timeFormat[2]}${sep[1]}${this.timeFormat[1]}${sep[2]}${this.timeFormat[0]}${sep[3]}`;
        }
    }
    /**
     * @description format array time
     * @see {Chronometer}
     */
    get timeFormat() {
        const time = this._chronometer.time;
        return Array(this.formatNumber(time[2]), this.formatNumber(time[1]), this.formatNumber(time[0]));
    }
    /**
     * @description return string 2 digit
     * @param n number to format
     */
    formatNumber(n) {
        return `${n > 9 ? n : `0${n}`}`;
    }
    /**
     * @description validator number
     * @param n number to valid
     */
    validNumber(n) {
        const enc = !isNaN(isNumber(n)) && n > 0;
        if (!enc) {
            console.error('Outdid maximo time no valid', n);
            this._chronometer.pause();
        }
        return enc ? n : 60;
    }
    /**
     * @description
     * @param chronometer object current chronometer
     * @see {Chronometer}
     * @param second increment the time
     * @see {increment} default [increment]="1"
     */
    setTime(chronometer, second = this.increment) {
        if (chronometer.second >= 0) {
            chronometer.second = chronometer.second + second;
            const diffSS = this.validNumber(chronometer.maxSecond);
            const diffMM = this.validNumber(chronometer.maxMinute);
            const hh = Math.trunc((chronometer.second / this.validNumber(chronometer.maxSecond)) / this.validNumber(chronometer.maxMinute));
            const mm = Math.trunc(chronometer.second / this.validNumber(chronometer.maxSecond)) - hh * diffMM;
            const ss = chronometer.second - Math.trunc(chronometer.second / diffSS) * diffSS;
            if (hh === chronometer.maxHour) {
                chronometer.second = 0;
                chronometer.time = new Array(0, 0, 0);
            }
            else {
                chronometer.time = new Array(hh, mm, ss);
            }
        }
        if (this.chronoEvents) {
            this.onChronoEvent.emit(chronometer);
        }
        return chronometer;
    }
    ngOnDestroy() {
        if (this.chronoSub) {
            this.chronoSub.unsubscribe();
        }
        if (this._chronometer.intervalSub) {
            this._chronometer.intervalSub.unsubscribe();
        }
        this._chronometer.onChronometer.unsubscribe();
    }
}
NgxChronometerDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[chronometer]',
                // tslint:disable-next-line:no-host-metadata-property
                host: {
                    '[innerText]': 'innerText'
                }
            },] }
];
NgxChronometerDirective.ctorParameters = () => [];
NgxChronometerDirective.propDecorators = {
    interval: [{ type: Input }],
    increment: [{ type: Input }],
    limitSecond: [{ type: Input }],
    maxSecond: [{ type: Input }],
    maxMinute: [{ type: Input }],
    maxHour: [{ type: Input }],
    isMinutes: [{ type: Input }],
    chronometer: [{ type: Input }],
    format: [{ type: Input }],
    chronoEvents: [{ type: Input }],
    onChronoEvent: [{ type: Output }]
};

class NgxChronometerModule {
}
NgxChronometerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxChronometerDirective],
                imports: [],
                exports: [NgxChronometerDirective],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/*
 * Public API Surface of ngx-chronometer
 */

/**
 * Generated bundle index. Do not edit.
 */

export { Chronometer, NgxChronometerModule, StatusChonometer, TimeChonometer, NgxChronometerDirective as ɵa };
//# sourceMappingURL=ngx-chronometer.js.map
